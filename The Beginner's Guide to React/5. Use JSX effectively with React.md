JSX is not an entirely different language, but it is a bit of an extension to the language, so knowing how you would express certain JavaScript things within the JSX syntax is important to using JSX effectively. In this lesson, we’ll explore a few different things you can do with JSX, like interpolation, composition, and spreading props. And we’ll compare these syntaxes with what is generated by babel so we understand how this translates to regular JavaScript calls into `React.createElement`.

If we wanted to create a variable for Hello World tesxt and we wanted to interpolate that variable's value into the children position, then I'm going to go ahead and copy this. We'll make this our children. Then we'll come in here and to interpolate we're going to use curly braces and put children in here. Anything you put between these two curly braces can be a JavaScript expression. Whatever that expression evaluates to is the value that gets placed into this position for the React.createElement call:
![](./assets/Pasted%20image%2020221201112531.png)

We can do the same thing for our className. If I copy the container and make a className variable, and instead of the quotes here, we'll put curly braces to suggest to the Babel compiler that we want this value to be evaluated as an expression, then we'll pass the className variable. If we save this, then we'll get the exact same result as we had before.
![](./assets/Pasted%20image%2020221201133710.png)

we can use any name for a variable; when you use the curly braces, that's basically telling Babel, "Leave this alone and pass it directly as the property that you pass for the props here and for the children arguments here."
![](./assets/Pasted%20image%2020221201133904.png)

Different versions how to use JSX:
![](./assets/Pasted%20image%2020221201134228.png)

Passing children property to JSX, one important thing to remember is that `children` is just a special prop that we could provide right here. Children is `children`. With that it works exactly the same way as it did before, except now instead of being compiled to add additional arguments, it's just using the shortcut here as one of the props.:
![](./assets/Pasted%20image%2020221201134337.png)

Self closing tags, as this is JSX and not HTML:
![](./assets/Pasted%20image%2020221201134432.png)

Destructuring and Spreading in JSX:
![](./assets/Pasted%20image%2020221201134533.png)

Adding more `props` to JSX will invoke `_extends` method:
![](./assets/Pasted%20image%2020221201134651.png)

Overriding some of the `props` in JSX, Then Babel is going to extend the props that we provided with the props that we're spreading. We get a single combined object for the second argument of the React.createElement call. Because of the way that object.assign works, if we wanted to override one of the properties in this props object, then we could do so simply by providing it after we spread those props in the props position for this element.:
![](./assets/Pasted%20image%2020221201134752.png)

In review, what we learned here is that you can interpolate values with these curly braces by putting any expression between the curly braces and have that expression passed along to the React.createElement API.

We also learned that you can spread props in the props position of a JSX element and those props will be combined with the other props that are provided to that element in a declarative and deterministic way.

Code:
```js
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@16.12.0/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16.12.0/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.8.3/babel.js"></script>
  <script type="text/babel">
    const rootElement = document.getElementById('root')
    const children = 'Hello World'
    const className = 'container'
    const props = {children, className}
    const element = <div {...props} />
    ReactDOM.render(element, rootElement)
  </script>
</body>
```